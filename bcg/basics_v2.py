# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/01_basics_v2.ipynb (unless otherwise specified).

__all__ = ['plot_target_vs_rest', 'plot_var_hists', 'show_correlations', 'get_Xy', 'get_model_feel',
           'get_feature_importance', 'get_partial_dependencies', 'plot_partial_dependencies', 'GraphGenerator',
           'get_only_Xi_to_Y', 'vis_g', 'get_gml']

# Cell
import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from scipy import stats
import networkx as nx
from sklearn import ensemble, metrics
import dowhy as dw

# Cell
def plot_target_vs_rest(obs:pd.DataFrame, target:str='Y'):
    in_cols = [col for col in obs.columns if target!=col]

    for in_col in in_cols:
        fig, ax = plt.subplots(figsize=(8,4), constrained_layout=True)
        ax.scatter(obs[in_col], obs[target], alpha=.1, marker='o')
        ax.set(xlabel=f'"{in_col}"', ylabel=f'"{target}"',
               title=f'"{target}" vs "{in_col}"')
        plt.show()

# Cell
def plot_var_hists(obs:pd.DataFrame, bins:int=50):
    for col in obs.columns:
        fig, ax = plt.subplots(figsize=(8,4), constrained_layout=True)
        ax.hist(col, data=obs, bins=bins, density=True)
        ax.set(title=f'"{col}" distribution', xlabel=f'"{col}"',
               ylabel=f'Frequency')
        plt.show()

# Cell
def show_correlations(obs:pd.DataFrame, method:str='spearman'):
    cols = obs.columns
    n = len(cols)
    fig, ax = plt.subplots(figsize=(8,8))
    ax.imshow(obs.corr(method=method))
    ax.set(xticks=range(n), xticklabels=cols,
           yticks=range(n), yticklabels=cols)
    plt.show()

# Cell
def get_Xy(obs:pd.DataFrame, target:str='Y'):
    not_target = [c for c in obs.columns if c!=target]
    X, y = obs.loc[:, not_target].values, \
           obs.loc[:, target].values.ravel()
    return X, y, not_target

# Cell
def get_model_feel(model, obs:pd.DataFrame, target:str='Y',
                   bins:int=50):
    X, y, not_target = get_Xy(obs, target=target)
    _y = model.predict(X)
    Δ = _y - y

    fig, ax = plt.subplots(figsize=(8,4), constrained_layout=True)
    ax.hist(Δ, bins=bins, density=True)
    ax.set(xlabel='$\Delta = y_p - y_t$', ylabel='Frequency',
           title='Model prediction residuals')
    plt.show()

    for var in not_target:
        fig, ax = plt.subplots(figsize=(8,4), constrained_layout=True)
        ax.scatter(obs[var], obs[target], alpha=.1, marker='o', label='truth')
        ax.scatter(obs[var], _y, alpha=.1, marker='x', label='prediction')
        ax.set(xlabel=f'"{var}"', ylabel=f'"{target}"',
               title='Model prediction vs truth: "{var}"')
        ax.legend(loc='best')
        plt.show()

# Cell
def get_feature_importance(m, obs:pd.DataFrame, target:str='Y',
                           metric:callable=metrics.mean_squared_error):
    X, y, not_target = get_Xy(obs, target=target)
    n_obs, n_row = X.shape
    scores = {}
    for i in range(n_row):
        _X = X.copy()
        np.random.shuffle(_X[:,i])
        _y = m.predict(_X)
        scores[i] = metric(y, _y)

    scores = pd.DataFrame([{'variable': not_target[i], 'feature_importance': scores[i]} for i in scores])
    scores.sort_values('feature_importance', ascending=False, inplace=True)
    return scores

# Cell
def get_partial_dependencies(model, obs:pd.DataFrame,
                             target:str='Y', max_num_obs:int=100,
                             max_num_ys:int=10):

    assert max_num_ys > 0
    X, y, not_target = get_Xy(obs, target=target)
    n_obs, n_row = X.shape
    part_deps = {}

    for ix, var in enumerate(not_target):

        ys = {}
        idp_vals = np.unique(X[:,ix])
        n_u = len(idp_vals)

        step = n_u//max_num_ys if max_num_ys >= n_u else 1
        idp_vals = idp_vals[::step]

        if max_num_obs:
            if max_num_obs >= n_obs:
                ixs = np.arange(n_obs)
            else:
                ixs = np.random.choice(np.arange(n_obs), size=max_num_obs,
                                       replace=False)
        for i, val in enumerate(idp_vals):
            _X = X[ixs,:].copy()
            _X[:,ix] = val
            _y = model.predict(_X)
            ys[i] = _y.copy()

        part_deps[var] = pd.DataFrame({val: ys[i] for i,val in enumerate(idp_vals)})
    return part_deps

# Cell
def plot_partial_dependencies(part_deps:pd.DataFrame,
                              target:str='Y'):

    for var in part_deps:
        fig, ax = plt.subplots(figsize=(8,4), constrained_layout=True)
        x = part_deps[var].columns.values
        for i, row in part_deps[var].iterrows():
            obs_line, = ax.plot(x, row.values, alpha=.1, lw=1, color='black', label='single obs.')
        avg = part_deps[var].mean(axis=0)
        avg_line, = ax.plot(x, avg, lw=2, color='yellow', label='avg.')
        ax.set(xlabel=f'"{var}"', ylabel=f'"{target}"', title=f'Partial dependency plot "{target}" vs "{var}"')
        ax.legend(loc='best', handles=[obs_line, avg_line])
        plt.show()

# Cell
class GraphGenerator:
    'Generates some specific directed graphs for `obs`'
    def __init__(self, obs:pd.DataFrame, target:str='Y'):
        self.not_targets = [col for col in obs.columns if col != target]
        self.target = target

# Cell
def get_only_Xi_to_Y(self):
    g = nx.DiGraph()
    for var in self.not_targets:
        g.add_edge(var, self.target)
    return g

GraphGenerator.get_only_Xi_to_Y = get_only_Xi_to_Y

# Cell
def vis_g(self, g:nx.DiGraph): nx.draw_spectral(g, with_labels=True)

GraphGenerator.vis_g = vis_g

# Cell
def get_gml(self, g:nx.DiGraph):
    return ''.join([v for v in nx.readwrite.gml.generate_gml(g)]); gml

GraphGenerator.get_gml = get_gml